#pragma kernel PrecomputeTwiddleFactorsAndInputIndices
#pragma kernel HorizontalStepFFT
#pragma kernel VerticalStepFFT
#pragma kernel HorizontalStepInverseFFT
#pragma kernel VerticalStepInverseFFT
#pragma kernel Scale
#pragma kernel Permute

static const float PI = 3.1415926;

RWTexture2D<float4> PrecomputeBuffer;
Texture2D<float4> PrecomputedData;
RWTexture2D<float2> Buffer0;
RWTexture2D<float2> Buffer1;
bool PingPong;
uint Step;
uint Size;

float2 ComplexMult(float2 a, float2 b)
{
	return float2(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);
}

float2 ComplexExp(float2 a)
{
	return float2(cos(a.y), sin(a.y)) * exp(a.x);
}


// Reference : https://zhuanlan.zhihu.com/p/623544248
// W_k_N = exp( - i * 2 * PI * k / N )
// N == Size == resolution (== 1024 in our demo)
// FFT function is 
// FFT(x) = a + W_k_N * b
// output is [W_real , W_imag , a_index , b_index ]
// W_real, W_imag is the real and imaginary part of W_k_N
// a_index, b_index is the index of a and b (as in last FFT layer )

// example , for Size = 8 , we can get :
// x = 0：a = 0 1 2 3 0 1 2 3   b = 4 5 6 7 4 5 6 7   k = 0 0 0 0 4 4 4 4   d = 4
// x = 1：a = 0 1 4 5 0 1 4 5   b = 2 3 6 7 2 3 6 7   k = 0 0 2 2 4 4 8 8   d = 2
// x = 2：a = 0 2 4 6 0 2 4 6   b = 1 3 5 7 1 3 5 7   k = 0 1 2 3 4 5 6 7   d = 1
[numthreads(1, 8, 1)]
void PrecomputeTwiddleFactorsAndInputIndices(uint3 id : SV_DispatchThreadID)
{
	uint d = Size >> (id.x + 1);
	float2 mult = 2 * PI * float2(0, 1) / Size;
	uint i = (2 * d * (id.y / d) + id.y % d) % Size;
	uint k = (id.y / d) * d;
	// float2 twiddle = ComplexExp(-mult * k);
	float2 twiddle = ComplexExp(float2( 0, -( 2.0 * PI / Size) * k));
	uint a_index = i;
	uint b_index = i + d;
	PrecomputeBuffer[id.xy] = float4(twiddle.x, twiddle.y, a_index, b_index);
	PrecomputeBuffer[uint2(id.x, id.y + Size / 2)] = float4(-twiddle.x, -twiddle.y, a_index, b_index);
}

// Reference : https://zhuanlan.zhihu.com/p/623544248
// Calculate the FFT of the input data in the horizontal direction
// x_t(n) = x_t-1(n) + W_k_N * x_t-1(n + d)
// iterate in id.x 
[numthreads(8, 8, 1)]
void HorizontalStepFFT (uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.x)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer0[uint2(inputsIndices.y, id.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer1[uint2(inputsIndices.y, id.y)]);
	}
}



// Reference : https://zhuanlan.zhihu.com/p/623544248
// Calculate the FFT of the input data in the vertical direction
// x_t(n) = x_t-1(n) + W_k_N * x_t-1(n + d)
// iterate in id.y
[numthreads(8, 8, 1)]
void VerticalStepFFT(uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.y)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer0[uint2(id.x, inputsIndices.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer1[uint2(id.x, inputsIndices.y)]);
	}
}

[numthreads(8, 8, 1)]
void HorizontalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.x)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(float2(data.r, -data.g), Buffer0[uint2(inputsIndices.y, id.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(float2(data.r, -data.g), Buffer1[uint2(inputsIndices.y, id.y)]);
	}
}

[numthreads(8, 8, 1)]
void VerticalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.y)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(float2(data.r, -data.g), Buffer0[uint2(id.x, inputsIndices.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(float2(data.r, -data.g), Buffer1[uint2(id.x, inputsIndices.y)]);
	}
}

[numthreads(8, 8, 1)]
void Scale(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] / Size / Size;
}

[numthreads(8, 8, 1)]
void Permute(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] * (1.0 - 2.0 * ((id.x + id.y) % 2));
}
